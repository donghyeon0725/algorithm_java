📌 알고리즘
-
* 프로그래밍 대회에 참가하는 것은 문제 해결 기술을 연마하기에 가장 좋은 방법
* 보통 "어떤 값을 읽어들여 어떤 값을 계산하는 프로그램을 작성하시오"의 형태를 가짐

<br/>

📌 알고리즘 문제 형식
-
* 문제
* 시간 및 메모리 제한
* 입력
* 출력
* 에제 입력
* 예제 출력

<br/>

📌 알고리즘 문제 풀이를 통해 배우는 것과 특징
-
* 텍스트 파일을 읽어들이고 텍스트 파일을 출력
* 명시적인 시간 제한과 메모리 제한이 있기 때문에 적절한 알고리즘, 자료구조를 써야함. 
* 원칙을 이해하고 변형해야만 풀 수 있는 문제들이 많음
* 정답과 오답의 여부가 명확하게 가려짐. 
* 수행 성능을 예측하는 데 익숙해져서 퍼포먼스가 중요한 프로그램을 짜는데에 도움
* 문제를 풀 때마다 처음부터 짜는 과정 때문에 프로그램의 작은 부분에 집중할 수 있는 계기를 만들어줌
* 간결한 프로그램을 작성하는데 도움을 줌 
* 대회가 끝난 후 제출된 소스를 모두 공개하기 때문에 고수들이 짠 코드를 직접 보고 비교해볼 수 있는 기회가 주어짐

<br/>


📌 문제 해결과정
-
1. 문제를 읽고 이해하기
2. 문제를 익숙한 용어로 재정의하기 
3. 어떻게 해결할지 계획을 세우기
4. 계획을 검증하기
5. 프로그램으로 구현하기
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾기 


<br/>

1단계. 문제를 읽고 이해
-
* 챔피언까지도.. 많은 사람이 하는 실수가 문제를 잘못 읽는 실수. 
* 사소한 제약 조건을 잘못 이해하면 풀 수 없게 되는 문제들이 많음

<br/>

2단계. 재정의와 추상화
-
* 문제를 자신이 아는 언어로 풀어쓰는 것
* 직관적인 이해를 위해 꼭 필요
* 추상화 => 본질만 남겨두고 축약하기. 프로그래밍이 나아갈 방향을 결정 

<br/>

3단계. 계획 세우기
-
* 사용할 알고리즘과 자료구조 선택하기
* 가장 중요한 단계

<br/>

4단계. 계획 검증하기
-
* 수행에 걸리는 시간과 사용하는 메모리가 문제의 제한 내에 들어가는지 확인 필요

<br/>

5단계. 계획 수행하기
-
* 코드에 작성하는 것

<br/>

6단계. 회고하기
-
* 장기적으로 가장 큰 영향을 미침.
* 자신이 해결한 과정을 돌이켜 보고 개선하기 
* 효과적으로 회고하기 위해 코드와 함께 자신의 경험을 기록하기
* 어떤 방식으로 접근했는지, 그리고 문제의 해법을 찾는데 결정적이었던 깨달음은 무엇이었는지
* 틀린 경우 오답 원인도 적기
* 다른 사람이 작성한 코드를 계속 찾아보기

<br/>

📌 문제를 풀지 못할 때
-
* 초보시절엔 일정시간이 지나도 답을 못찾으면 다른 사람의 코드나 풀이 참조하기 => 복기를 동반해야함 (내가 접근할 때 왜 이를 떠올리지 못했는지)

<br/>


📌 문제 해결 전략(체계적인 접근을 위한 질문들)
-

* 비슷한 문제를 풀어본적이 있는지
* 단순한 방법에서 시작할 수 있는지
    - 가장 단순한 알고리즘을 만들어보는 것 
* 문제를 푸는 과정을 수식화 
    - 손으로 여러 간단한 입력을 작성해보기 -> 그리고 검토해보기
* 문제를 단순화 할 수 없는지
    - 제약조건을 없애보기
    - 계산해야하는 변수의 양 줄여보기
    - 다차원 공간의 문제를 1차원으로 줄여서 생각해보기
* 그림으로 그려볼 수 있는지
* 문제를 수식으로 표현할 수 있는지
    - 예를 들면 논리의 정당성 검증 예시
        - 선수 i는 선수 j에게 반드시 패배함
        - 선수 i와 선수 j가 서로 상대에게 이길 가능성이 있음
        - => 딱 보면 논리가 잘못 되었음을 알 수 있지만, 이를 수식으로 나타내보자. 선수 k가 있을 때 최고 기록을 best[k], 최저기록을 worst[k] 로 나타내면 수식은 이러하다.
        - 선수 i는 선수 j에게 반드시 패배함 => best[i] < worst[j]
        - 선수 i와 선수 j가 서로 상대에게 이길 가능성이 있음 => ( best[i] > worst[j] ) && ( best[j] > worst[i] )
* 문제를 분해할 수 있는지
    - 더 쉬운 형태로 문제를 변형
    - 예를 들어 문제의 제약 조건을 분해
* 뒤에서부터 생각해서 문제를 풀수 있는지
    - 사다리게임
* 순서를 강제할 수 있는지
    - 제약 조건이 없거나 클 때, 그 중 일부 제약조건만을 만족시키는 방법으로 풀어보거나, 자신이 임의로 제약조건을 걸어서 테스트 해야하는 케이스를 줄이는 방법
    - 경우의 수를 셀때도 유리
* 특정 형태의 답만 고려할 수 있는지
    - 정규화 하는 방법 (결과적으로 똑같은 것들을 그룹으로 묶은 뒤, 각 그룹의 대표들만을 고려하는 방법


<br/>

📌 코딩과 디버깅
-
* 읽기 쉬운 코드를 작성하기
* 되도록 짧게 작성하기
    - 전역 변수는 일반적인 실무에서 많이 사용하지 않는 것이 좋으나, 코딩 테스트의 경우 로직이 짧아서 큰 무리가 없음 
* 되도록 익숙한 코드로 작성하기
    - 매일 쓰던 코드가 검증 되어 있어서 쉬움. 예를 들면 for 문 돌릴 때 범위를 < 으로 할 건지, <= 으로 할건지는 평소에 쓰던걸로 하기. foreach 구문 같은 것을 사용하면 좋음 
* 표준 라이브러리 공부하기
    - 배열, 스택, 큐, 리스트, 사전 등등 이미 표준에서 나온 자료형을 사용하는 방법 등에 대해 익혀놓는 것이 좋음 
* 일관적이고 명로한 명명법 사용하기
* 모든 자료를 정규화해서 저장하기
    - 데이터를 저장할 때 이미 같은 종류인데, 형태만 다른 데이터는 없는지 등등을 검사해서 저장
    - 예를 들면 2/3 과 4/6은 같은 값이나, 문자열이 달라 해시값이 다르게 되는 문제가 있을 수 있음 
    - 각도의 경우도 누구는 30도 누구는 330도 누구는 690도 로 쓰면 구현이 아주 어려워짐
    - 실무의 경우 시간이나 인코딩 표준을 정해서 자료를 다루는 것이 예시가 될 수 있음
* 코드와 데이터를 분리하기
    - 논리적인 로직이 아닌 코드적인 것은 자료형으로 구분해서 쓰는게 좋다. 예를들어 1년 12달을 표현한다고 하면 if문을 12번 쓸게 아닌, 12칸 크기의 배열을 생성하는 것이 정답
    - 체스 같은 경우 기사말이 움직이는 경로를 아래와 같이 저장해둘수 있음
        - const int knightDx[8] = {2, 2, -2, -2, 1, 1, -1, -1 };
        - const int knightDy[8] = {1, -1, 1, -1, 2, 2, 2, -2 };

<br/>
        
📌 자주하는 실수
-
* 산술 오버플로
    - 자료형이 최대 저장할 수 있는 값을 벗어나는 것 => 컴파일러가 잡아주지도 않아서 더 큰 문제가 됨
    - 특히, 문제를 계산하는 중간에 값이 너무나도 커져 버리는 경우 문제가 많이 발생함.
    - 이 문제 해결을 위해 표준 라이브러리 사용을 권장
    
* 배열 범위 밖 원소에 접근 : Out of Index
* 일관 되지 않은 범위 표현 방식의 사용
    - 닫힌 구간 표현 법 0 <= x <= 7
    - 열린 구간 표현 법 -1 < x < 8
    - 반 열린 구간 표현 법 0 <= x < 8           => 제일 깔끔
* Off-by-one
    - 계산의 로직은 흐름은 맞으나 하나가 많거나 모자라 틀리는 문제 
        - ex) 길이가 20인 공간에 10에 한번씩 기둥을 세우면 기둥 2개가 아닌 3개 필요
    - 입력값 중 최소 값을 찾아서 직접 머리속에서 입력해가며 프로그래 작성하는 방법
* 컴파일러가 잡아주지 못하는 상수 오타 
    - 철자 실수 주의하기 
* 스택 오버 플로
    - 알고리즘에서 재귀호출을 사용하는 경우가 많은데 이때 오버 플로에 걸리진 않는지, 테스트 환경의 스택 허용량에 대해 미리 알아둘 필요성 있음
* 최소, 최대 예외 잘못 다루기
    - 코드를 짤때 항상 최대값, 최소값 2개를 한번씩만 넣어봐도 많은 에러를 잡을 수 있음
* 연산자 우선순위 잘못 쓰기 
    - if ( b & 1 == 0 ) 의 작동순서는 if ( b & (1 == 0) )
* 너무 느린 입출력 방식 선택
    - 자바의 경우 scanner이냐 bufferReader 이냐에 따라 속도가 많이 차이남 => 찾아봐야함
* 변수 초기화 문제
    - 전역 변수의 경우 초기화를 잘 해줘야함
    - 입력값 케이스를 늘려봄으로써(2개 이상) 의존관계 때문에 우연히 답이 나오는 경우 방지

<br/>
        
📌 디버깅과 테스팅
-
* 코테는 소스가 짧아서 디버깅 보다는 눈 디버깅이 빠름
* 재귀 호출이나 반복이 많으면 디버깅 사용이 어려움
* 눈 디버깅이 안되면 에초에 코드를 복잡하게 짠 잘못


<br/>

📌 팁
-
* 작은 입력값을 주면서 실행해보기
* 계산 결과를 중간중간 출력하는 출력문 사용하기
* 단정문 (assertion)을 쓰는 것. => 예상값이 아닐때 오류나 return 해버림으로써, 어디서 문제가 발생했는지 알수 있게 해줌


<br/>

📌 테스트에 관하여 
-
* 테스트를 자동화하면 편함
    1. 테스트할 로직을 함수화 하기
    2. 입력값을 생성해주는 작은 로직 짜기
    3. 예상값이 맞는지 확인해주는 로직 짜기

* 너무 큰 값이 될 여지가 있는 곳은 형태를 주의 깊게 봐야함 
    - 곱셈과 나눗셈이 모두 있는 경우 나눗셈을 먼저 하기
    - 뺄셈과 덧셈이 있는 경우 뺄셈을 먼저하기 => 너무 값이 커지는 것을 막을 수 있음

* 적당히 더미값을 쓰면 예외 처리를 피할 수 있음
    - 예를 들면 링크드 리스트를 만들때 첫 노드를 기본 세팅하고 들어간다던지,
    - 최소 값을 찾는 로직에 int의 최대 값을 먼저 넣어두면 배열이 비었는지를 검사할 필요는 없으 ㅁ

* 오버플로를 막기 위해서 미리 수식에 캐스팅 해주는 작업을 할 수 있음 
    - 때때로 점화식 (어떤 함수를 특정 다른 수가 들어간 자신의 함수를 포함시킨 표현식 =>  f(n) = n * f(n-1) )을 사용하면 빠르게 계산할 수 있는 경우가 있음
* 자료형의 프로모션 
    - 자료형을 계산할 때 서로 다른 두 타입이 만나면 같은 자료형으로 변환 되는 것을 프로모션이라고 함 
    - 계산할 때 특히 프로모션이 없는지 주의해서 계산한다.


<br/>
